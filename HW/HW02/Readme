Музикална теория
Тонове

Основен градивен елемент на всяко едно музикално произведение и негова най-атомарна част са, you guessed it, тоновете. Тоновете са най-просто казано вибрацията на дадено тяло, които трептят с определена честота. Отвъд това няма да си говорим за физичните свойства на тоновете, макар че и там има какво интересно да се каже.

В западната музика най-често използваме 12 такива предефинирани честоти, определени от различните височини (i.e. скоростта на трептенето, честотата) на тоновете. Тоновете назоваваме и записваме с ноти, които си имат определени имена. Много от вас вероятно ще се досетят веднага за До-Ре-Ми-Фа-Сол-Ла-Си (за разлика от в училище, последното "До" няма да го броим два пъти), но това са само 8 ноти / тона, а не 12?!

Преди визуализацията на въпросната концепция с клавиши на пиано, искаме да направим едно уточнение - за целите на домашното ще работим със западните имена на нотите, а не както по-горе. Това по-горе беше, за да ви припомним часовете по музика, но занапред ще искаме да работим с латинските букви, обозначаващи въпросните тонове:

    C - До
    D - Ре
    E - Ми
    F - Фа
    G - Сол
    A - Ла
    B - Си

Та, защо 12, а не 8?! Ако си представите как изглеждат клавишите на пианото, вероятно ще се сетите, че има бели клавиши и между някои от тях - по-малки, черни клавиши. Белите клавиши отговарят на 8-те тона, които изброихме по-горе. Черните са "междинни" тонове между някои от нотите. Тези тонове, между познатите ни ноти, отбелязваме с # или "диез" (да, знаем, че има и алтернатива, но няма да я споменаваме, защото на тези от вас, които нямат грам понятие от тези концепции, ще им дойде в повече).

Ето визуален пример за това как изглеждат всичките 12 тона / ноти спрямо клавишите на пиано:

Хроматична скала

Тези 12 ноти дефинират една "октава". Причината в училище (а и на горната картинка) да ни учеха да повтаряме "До" накрая е, че след като "приключат" тоновете от тази октава - все пак има по-високи и следващата октава отново работи със същите 12 имена на тоновете. Следователно след C, D, E, F, G, A, B… Имаме пак C… И после D, и така нататък. За целите на днешното домашно няма да взимаме предвид концепциите за октави, но е важно да възприемете тоновете като последователни и циклични, а не сякаш приключват със B. Ето ви картинка за по-лесно илюстиране:

Хроматична скала в кръгче

На този етап вероятно се чудите какво определя наличието на тези 12 тона и защо има "междинни" такива. Тук трябва да си поговорим за…
Интервали

Интервалите, най-просто казано, са разстоянията между височините на два тона. Между всеки два от дванайсетте тона има интервал от точно един полутон. С други думи, ако започнем от C, всяка стъпка по клавишите на пианото, включвайки и белите и черните клавиши, е през интервал от един полутон. C->C# - един полутон, C#->D - един полутон, E->F - един полутон и така нататък.

Следователно ако скочим с два клавиша, получаваме интервал от 2 стъпки, 2 полутона или можем да го наречем "цял тон". Разстоянието, интервалът между C и D - два полутона / един тон, между C# и D# - същото. Съответно имаме интервали от по 3, 4, 5 и така до 12 скока разстояние, където вече се "връщаме" в оригиналния тон, от който сме започнали да броим.

Всеки от тези интервали си има определено име, ние ще използваме имената на английски:

    0 - unison
    1 - minor 2nd
    2 - major 2nd
    3 - minor 3rd
    4 - major 3rd
    5 - perfect 4th
    6 - diminished 5th
    7 - perfect 5th
    8 - minor 6th
    9 - major 6th
    10 - minor 7th
    11 - major 7th

На български има по-готини имена като "мажорна терца", "квинта", "септима" и прочие, но за домашното ще се придържаме към английските такива.

Остана ни едно последно нещо, преди да можем да пристъпим към условието на домашното.
Акорди

Основата на акордите всъщност е доста проста - комбинацията от два или повече (различни) тона образува акорд. С други думи ако изсвирим заедно C и G - вече имаме акорд (по-конкретно C5). Ако към този акорд добавим още един тон - получаваме нов акорд. Ако направим комбинация от C, E и G - получаваме акорд дефиниран от тези 3 тона (в този случай - C). Ще забележите, че и двата акорда са с имена, производни на нотата C. Тази нота наричаме "основен тон" или "root", а акордът назоваваме на базата на производния тон.

Добре де, но в единия случай имаме C5, в другия C, а ако вземем да направим акорд от C, D# и G, ще получим още по-интересното Cm (C minor). Оттук идва и популярната фраза "Fingering A minor" (ако root ни беше A, разбира се). Защо?

Тук идва и идеята за "качествата" на акорда. Не, не колко добре сме го изсвирили, това е друга тема. Няма да задълбаваме безкрайно в това, тъй като е обект на поне двусеместриален курс, част от бакалавърска степен в Музикалната академия, но това, което искаме да знаем, е, че "качествата" на акорда са директно последствие от взаимоотношенията между отделните тонове в акорда. Това, върху което ще се фокусираме, е наличието или липсата на minor или major 3rd, но за това - малко по-натам в условието.
Най-накрая - Условието!
Tone

Напишете клас Tone, който да описва понятието за музикален тон. Искаме да може да се инстанцира по следния начин:

c_sharp = Tone("C#") # At least not Java

Искаме да имаме стрингова репрезентация на тоновете, работеща по следния начин:

print(str(c_sharp))
# "C#"

Уговорка: Както споменахме по-горе - за целите на домашното няма да се занимаваме с октавите на дадените тонове, приемаме, че всички тонове C са едно и също.
Interval

Напишете клас Interval, който да описва понятието за интервал. Искаме да може да се инстанцира по следния начин:

number_of_semitones = 3 # Където 3 е брой полутонове разстояние или "стъпки" според горните обяснения
minor_third = Interval(number_of_semitones)

Искаме да имаме стрингова репрезентация на интервалите, работеща по следния начин:

print(str(minor_third))
# "minor 3rd"
# С малки букви

Уговорка: Интервалите могат да приемат произволни естествени числа, като Interval(13) е същото като Interval(1) и неговата репрезентация би била minor 2nd. С други думи отново се абстрахираме от октавите.
Chord

Напишете клас Chord, който да описва понятието за акорд. Искаме да може да се инстанцира по следния начин:

c, d_sharp, g = Tone("C"), Tone("D#"), Tone("G")
c_minor_chord = Chord(c, d_sharp, g)

Имаме следните уговорки:

    Първият параметър при инстанциране винаги е основния тон (позиционен).
    Останалите тонове са произволен брой и с произволна подредба. За подредбата повече информация малко по-надолу.
    Повторенията на тоновете не се отразяват. С други думи дори да имате 10 пъти C - пази се единствено информация за тона C (важно за долната подточка).
    Приемаме опит за създаване на акорд от 1 тон за недефинирано поведение и искаме да се възбуди TypeError с текст "Cannot have a chord made of only 1 unique tone".

Още един пример:

c, another_c = Tone("C"), Tone("C")
sissy_chord = Chord(c, another_c)
Traceback (most recent call last):
  File ...
    ...
TypeError: Cannot have a chord made of only 1 unique tone

Искаме да имаме стрингова репрезентация на акордите, работеща по следния начин:

print(str(c_minor_chord))
# "C-D#-G"
# Описание на всички съдържащи се тонове, започващи от "root"-а,
# подредени по редът си в хроматичната скала (C, C#, D, D#... B), разделени от тире
# Както казахме по-горе - повторения няма

c, another_c, f = Tone("C"), Tone("C"), Tone("F")
csus4_chord = Chord(c, f, another_c) # Спокойно, не е важно какъв точно е този акорд
print(str(csus4_chord))
# "C-F"

f, c, d, a, g = Tone("F"), Tone("C"), Tone("D"), Tone("A"), Tone("G")
f_sixth_ninth_chord = Chord(f, c, d, a, g)
print(str(f_sixth_ninth_chord))
# "F-G-A-C-D"
# Root-ът е водещ, оттам насетне всички са подредени спрямо редът си в скалата
# релативно спрямо основния тон

За да не навлизаме в дълбините на "качествата" на акордите, ще се ограничим до следните 3 качества - "минорен", "мажорен" и "power" (ако някой знае как е на български - да каже) акорди, определени от следните методи:
Chord.is_minor

Ако акордът има в себе си тон, който заедно с основният (root) образува "minor 3rd" - той е минорен и функцията трябва да ни върне True. В противен случай - False:

c_minor_chord = Chord(Tone("C"), Tone("D#"), Tone("G"))
print(c_minor_chord.is_minor())
# True
# Тонът D# и root-ът C са на разстояние един от друг, образуващо интервал "minor 3rd"

c_not_minor_chord = Chord(Tone("C"), Tone("D"), Tone("G"))
print(c_not_minor_chord.is_minor())
# False
# Няма тон, който заедно с root-а да образува "minor 3rd", така че приемаме, че акордът не е минорен

Chord.is_major

Ако акордът има в себе си тон, който заедно с основният (root) образува "major 3rd" - той е мажорен и функцията трябва да ни върне True. В противен случай - False:

c_major_chord = Chord(Tone("C"), Tone("E"), Tone("G"))
print(c_major_chord.is_major())
# True
# Тонът E и root-ът C са на разстояние един от друг, образуващо интервал "major 3rd"

c_not_major_chord = Chord(Tone("C"), Tone("D"), Tone("G"))
print(c_not_major_chord.is_major())
# False
# Няма тон, който заедно с root-а да образува "major 3rd", така че приемаме, че акордът не е мажорен

Chord.is_power_chord

Ако акордът няма в себе си тон, който заедно с основният (root) образува "minor 3rd", нито пък "major 3rd" - той е power акорд и функцията трябва да ни върне True. В противен случай - False:

c_power_chord = Chord(Tone("C"), Tone("F"), Tone("G"))
print(c_power_chord.is_power_chord())
# True
# Нямаме нито "minor 3rd", нито "major 3rd" интервал спрямо основния тон

# И преди някой, който е бил в дебрите на музикалната теория да ни направи забележка,
# че въпросният акорд всъщност не е power chord, а суспендиран (или там както се води
# на български) - искате ли да ви караме да отбелязвате и суспендираните акорди? :D

c_not_power_chord = Chord(Tone("C"), Tone("E"), Tone("G"))
print(c_not_power_chord.is_power_chord())
# False
# Тонът E и root-ът C са на разстояние един от друг, образуващо интервал "major 3rd", следователно нямаме power chord

Операции

Искаме да имаме възможност да извършваме следните операции с обектите от горните класове:
Събиране на тонове

Искаме да можем да събираме обекти от клас Tone и резултат от операцията да бъде обект от клас Chord:

c, g = Tone("C"), Tone("G")
result_chord = c + g # result_chord е обект от тип Chord
print(result_chord)
# "C-G"

Изваждане на тонове

Искаме да можем да изваждаме обекти от клас Tone и резултат от операцията да бъде обект от клас Interval:

c, g = Tone("C"), Tone("G")
result_interval = g - c # result_interval е обект от тип Interval
print(result_interval)
# "perfect 5th"

Събиране на тон с интервал

Искаме да можем да събираме тонове с интервали и резултат от операцията да бъде нов тон с променена височина:

c = Tone("C")
perfect_fifth = Interval(7)
result_tone = c + perfect_fifth
print(result_tone)
# "G"

c = Tone("C")
result_tone = c + Interval(12)
print(result_tone)
# "C"
# Тук забелязваме "цикличността" на 12-те тона - тонът е отново C, тъй като не се
# ангажираме с концепцията за октави

g = Tone("G")
perfect_fifth = Interval(7)
result_tone = g + perfect_fifth
print(result_tone)
# "D"

Забележка: Искаме това да работи само когато тонът е отляво на знакът за събиране. Когато тонът е отдясно, го приемаме за недефинирано поведение и искаме да се възбуди TypeError с текст "Invalid operation". Семпло, но няма да ви вгорчаваме живота… Повече.
Изваждане на интервал от тон

Искаме да можем да изваждаме интервал от тон и резултат от операцията да бъде нов тон с променена височина, но този път в обратна посока, т.е. "надолу":

c = Tone("C")
perfect_fifth = Interval(7)
result_tone = c - perfect_fifth
print(result_tone)
# "F"
# Тук отново забелязваме "цикличността" на 12-те тона

Забележка: Искаме това да работи само когато тонът е отляво на знакът за изваждане. Когато тонът е отдясно, го приемаме за недефинирано поведение и искаме да се възбуди TypeError с текст "Invalid operation". Ако искате може и друг… Просто ще ви фейлнат тестовете.
Събиране на интервали

Искаме да можем да събираме обекти от клас Interval и резултат от операцията да бъде нов обект от клас Interval:

perfect_fifth = Interval(7)
minor_third = Interval(3)
result_interval = perfect_fifth + minor_third
print(result_interval)
# "minor 7th"

Събиране на акорд с тон

Искаме да можем да събираме акорди с тонове и резултат от операцията да бъде нов акорд:

c5_chord = Chord(Tone("C"), Tone("G"))
result_chord = c5_chord + Tone("E")
print(result_chord)
# C-Е-G

Изваждане на тон от акорд

Искаме да можем да изваждаме тон от акорд. Ако акордът съдържа три или повече, тона ще се върне нов акорд, в противен случай ще го третираме като недефинирано поведение и искаме да се възбуди TypeError с текст "Cannot have a chord made of only 1 unique tone".

c_major_chord = Chord(Tone("C"), Tone("E"), Tone("G"))
result_chord = c_major_chord - Tone("E")
print(result_chord)
# C-G

c_power_chord = Chord(Tone("C"), Tone("G"))
result_chord = c_power_chord - Tone("G")
Traceback (most recent call last):
  File ...
    ...
TypeError: Cannot have a chord made of only 1 unique tone

Изваждането на несъществуващ тон също е недефинирано поведение, отново искаме TypeError, но този път искаме текстът да бъде "Cannot remove tone <Tone> from chord <Chord>", където <Tone> и <Chord> са съотвените стрингови репрезентации на тона и акорда:

c_power_chord = Chord(Tone("C"), Tone("G"))
result_chord = c_power_chord - Tone("E")
Traceback (most recent call last):
  File ...
    ...
TypeError: Cannot remove tone E from chord C-G

Събиране на акорди

Искаме да можем да събираме обекти от клас Chord и резултат от операцията да бъде нов обект от клас Chord:

c5_chord = Chord(Tone("C"), Tone("G"))
this_other_chord = Chord(Tone("A"), Tone("B"))
result_chord = c5_chord + this_other_chord
print(result_chord)
# "C-G-A-B"

И финално
Chord.transposed

Умишлено оставихме този метод за накрая, тъй като горните операции описват поведението на тоновете когато ги "изместваме" нагоре или надолу, което е важно за финалната ни функция.

Последен термин, обещавам… Искаме да можем да "транспонираме" даден акорд, т.е. да изместим всеки един от тоновете му с един и същ интервал. Интервалът в нашият случай ще бъде обект от тип Interval, а промяната на тоновете следва да може да се случва както нагоре, така и надолу, определено от знака пред интервала. Тъй като методът е transposed - искаме като резултат да ни връща нов обект от тип Chord.

Ето и пример:

print(str(c_minor_chord))
# "C-D#-G"
d_minor_chord = c_minor_chord.transposed(Interval(2))
print(str(d_minor_chord))
# "D-F-A"

a_sharp_minor_chord = d_minor_chord.transposed(-Interval(4))
print(str(a_sharp_minor_chord))
# "A#-C#-F"

Възбуждане на грешки?!

Утре (31.10) ще говорим за това. И все пак, за хората, които много бързат, в Python грешки се хвърлят по следния начин:

raise TypeError("текст")

That's pretty much it, поне за целите на домашното.
Утре - по-интересни неща по темата.
За любознателните

    Ако ви е интересно защо на английски нотите започват от C, а не от A, защо тоновете са 12, но разпределени шантаво и други интересни неща, можете да прочетете повече по темата тук.


